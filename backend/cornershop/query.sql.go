// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package cornershopdb

import (
	"context"
)

const createDevice = `-- name: CreateDevice :one
INSERT INTO device (
  id,
  agent
) VALUES (?,?)
RETURNING id
`

type CreateDeviceParams struct {
	ID    string `json:"id"`
	Agent string `json:"agent"`
}

func (q *Queries) CreateDevice(ctx context.Context, arg CreateDeviceParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createDevice, arg.ID, arg.Agent)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createEpisode = `-- name: CreateEpisode :one
INSERT INTO episode (
  anime_season ,
  anime_title ,
  audio_term ,
  episode_number ,
  file_checksum ,
  file_extension ,
  file_name ,
  release_group ,
  source ,
  video_resolution ,
  video_term
) 
VALUES (?,?,?,?,?,?,?,?,?,?,?)
RETURNING id, anime_season, anime_title, audio_term, episode_number, file_checksum, file_extension, file_name, release_group, source, video_resolution, video_term
`

type CreateEpisodeParams struct {
	AnimeSeason     string `json:"anime_season"`
	AnimeTitle      string `json:"anime_title"`
	AudioTerm       string `json:"audio_term"`
	EpisodeNumber   string `json:"episode_number"`
	FileChecksum    string `json:"file_checksum"`
	FileExtension   string `json:"file_extension"`
	FileName        string `json:"file_name"`
	ReleaseGroup    string `json:"release_group"`
	Source          string `json:"source"`
	VideoResolution string `json:"video_resolution"`
	VideoTerm       string `json:"video_term"`
}

func (q *Queries) CreateEpisode(ctx context.Context, arg CreateEpisodeParams) (Episode, error) {
	row := q.db.QueryRowContext(ctx, createEpisode,
		arg.AnimeSeason,
		arg.AnimeTitle,
		arg.AudioTerm,
		arg.EpisodeNumber,
		arg.FileChecksum,
		arg.FileExtension,
		arg.FileName,
		arg.ReleaseGroup,
		arg.Source,
		arg.VideoResolution,
		arg.VideoTerm,
	)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.AnimeSeason,
		&i.AnimeTitle,
		&i.AudioTerm,
		&i.EpisodeNumber,
		&i.FileChecksum,
		&i.FileExtension,
		&i.FileName,
		&i.ReleaseGroup,
		&i.Source,
		&i.VideoResolution,
		&i.VideoTerm,
	)
	return i, err
}

const createSession = `-- name: CreateSession :exec
INSERT INTO user_session (
  device,
  anime_title,
  episode_number
) VALUES (?,?,?)
`

type CreateSessionParams struct {
	Device        string `json:"device"`
	AnimeTitle    string `json:"anime_title"`
	EpisodeNumber string `json:"episode_number"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) error {
	_, err := q.db.ExecContext(ctx, createSession, arg.Device, arg.AnimeTitle, arg.EpisodeNumber)
	return err
}

const deleteEpisode = `-- name: DeleteEpisode :exec
DELETE FROM episode
WHERE id ='?'
`

func (q *Queries) DeleteEpisode(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteEpisode)
	return err
}

const getDevice = `-- name: GetDevice :one
SELECT id from device
WHERE id = ? limit 1
`

func (q *Queries) GetDevice(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRowContext(ctx, getDevice, id)
	err := row.Scan(&id)
	return id, err
}

const getEpisode = `-- name: GetEpisode :one
SELECT id, anime_season, anime_title, audio_term, episode_number, file_checksum, file_extension, file_name, release_group, source, video_resolution, video_term FROM episode
WHERE id = ? LIMIT 1
`

func (q *Queries) GetEpisode(ctx context.Context, id int64) (Episode, error) {
	row := q.db.QueryRowContext(ctx, getEpisode, id)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.AnimeSeason,
		&i.AnimeTitle,
		&i.AudioTerm,
		&i.EpisodeNumber,
		&i.FileChecksum,
		&i.FileExtension,
		&i.FileName,
		&i.ReleaseGroup,
		&i.Source,
		&i.VideoResolution,
		&i.VideoTerm,
	)
	return i, err
}

const getPlayback = `-- name: GetPlayback :one
SELECT id, device, anime_title, episode_number, playing, transcoding, position from user_session 
WHERE device = ?
`

func (q *Queries) GetPlayback(ctx context.Context, device string) (UserSession, error) {
	row := q.db.QueryRowContext(ctx, getPlayback, device)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.Device,
		&i.AnimeTitle,
		&i.EpisodeNumber,
		&i.Playing,
		&i.Transcoding,
		&i.Position,
	)
	return i, err
}

const listEpisodes = `-- name: ListEpisodes :many
SELECT id, anime_season, anime_title, audio_term, episode_number, file_checksum, file_extension, file_name, release_group, source, video_resolution, video_term FROM episode
ORDER BY anime_title
`

func (q *Queries) ListEpisodes(ctx context.Context) ([]Episode, error) {
	rows, err := q.db.QueryContext(ctx, listEpisodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Episode
	for rows.Next() {
		var i Episode
		if err := rows.Scan(
			&i.ID,
			&i.AnimeSeason,
			&i.AnimeTitle,
			&i.AudioTerm,
			&i.EpisodeNumber,
			&i.FileChecksum,
			&i.FileExtension,
			&i.FileName,
			&i.ReleaseGroup,
			&i.Source,
			&i.VideoResolution,
			&i.VideoTerm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePlayingSession = `-- name: UpdatePlayingSession :exec
UPDATE user_session 
SET playing = ?
WHERE device = ?
`

type UpdatePlayingSessionParams struct {
	Playing bool   `json:"playing"`
	Device  string `json:"device"`
}

func (q *Queries) UpdatePlayingSession(ctx context.Context, arg UpdatePlayingSessionParams) error {
	_, err := q.db.ExecContext(ctx, updatePlayingSession, arg.Playing, arg.Device)
	return err
}

const updateSession = `-- name: UpdateSession :exec
UPDATE user_session 
SET playing = ?,
  anime_title = ?,
  episode_number  = ?,
  transcoding  = ?,
  position  = ?
WHERE device = ?
`

type UpdateSessionParams struct {
	Playing       bool   `json:"playing"`
	AnimeTitle    string `json:"anime_title"`
	EpisodeNumber string `json:"episode_number"`
	Transcoding   bool   `json:"transcoding"`
	Position      int64  `json:"position"`
	Device        string `json:"device"`
}

func (q *Queries) UpdateSession(ctx context.Context, arg UpdateSessionParams) error {
	_, err := q.db.ExecContext(ctx, updateSession,
		arg.Playing,
		arg.AnimeTitle,
		arg.EpisodeNumber,
		arg.Transcoding,
		arg.Position,
		arg.Device,
	)
	return err
}
