// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package cornershopdb

import (
	"context"
)

const createEpisode = `-- name: CreateEpisode :one
INSERT INTO episode (
  anime_season ,
  anime_title ,
  audio_term ,
  episode_number ,
  file_checksum ,
  file_extension ,
  file_name ,
  release_group ,
  source ,
  video_resolution ,
  video_term
) VALUES (
  ?, ?, ?, ? ,?, ? ,? ,?, ?, ? ,?
)
RETURNING id, anime_season, anime_title, audio_term, episode_number, file_checksum, file_extension, file_name, release_group, source, video_resolution, video_term
`

type CreateEpisodeParams struct {
	AnimeSeason     string `json:"anime_season"`
	AnimeTitle      string `json:"anime_title"`
	AudioTerm       string `json:"audio_term"`
	EpisodeNumber   string `json:"episode_number"`
	FileChecksum    string `json:"file_checksum"`
	FileExtension   string `json:"file_extension"`
	FileName        string `json:"file_name"`
	ReleaseGroup    string `json:"release_group"`
	Source          string `json:"source"`
	VideoResolution string `json:"video_resolution"`
	VideoTerm       string `json:"video_term"`
}

func (q *Queries) CreateEpisode(ctx context.Context, arg CreateEpisodeParams) (Episode, error) {
	row := q.db.QueryRowContext(ctx, createEpisode,
		arg.AnimeSeason,
		arg.AnimeTitle,
		arg.AudioTerm,
		arg.EpisodeNumber,
		arg.FileChecksum,
		arg.FileExtension,
		arg.FileName,
		arg.ReleaseGroup,
		arg.Source,
		arg.VideoResolution,
		arg.VideoTerm,
	)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.AnimeSeason,
		&i.AnimeTitle,
		&i.AudioTerm,
		&i.EpisodeNumber,
		&i.FileChecksum,
		&i.FileExtension,
		&i.FileName,
		&i.ReleaseGroup,
		&i.Source,
		&i.VideoResolution,
		&i.VideoTerm,
	)
	return i, err
}

const deleteEpisode = `-- name: DeleteEpisode :exec
DELETE FROM episode
WHERE id = ?
`

func (q *Queries) DeleteEpisode(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteEpisode, id)
	return err
}

const getEpisode = `-- name: GetEpisode :one
SELECT id, anime_season, anime_title, audio_term, episode_number, file_checksum, file_extension, file_name, release_group, source, video_resolution, video_term FROM episode
WHERE id = ? LIMIT 1
`

func (q *Queries) GetEpisode(ctx context.Context, id int64) (Episode, error) {
	row := q.db.QueryRowContext(ctx, getEpisode, id)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.AnimeSeason,
		&i.AnimeTitle,
		&i.AudioTerm,
		&i.EpisodeNumber,
		&i.FileChecksum,
		&i.FileExtension,
		&i.FileName,
		&i.ReleaseGroup,
		&i.Source,
		&i.VideoResolution,
		&i.VideoTerm,
	)
	return i, err
}

const listEpisodes = `-- name: ListEpisodes :many
SELECT id, anime_season, anime_title, audio_term, episode_number, file_checksum, file_extension, file_name, release_group, source, video_resolution, video_term FROM episode
ORDER BY anime_title
`

func (q *Queries) ListEpisodes(ctx context.Context) ([]Episode, error) {
	rows, err := q.db.QueryContext(ctx, listEpisodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Episode
	for rows.Next() {
		var i Episode
		if err := rows.Scan(
			&i.ID,
			&i.AnimeSeason,
			&i.AnimeTitle,
			&i.AudioTerm,
			&i.EpisodeNumber,
			&i.FileChecksum,
			&i.FileExtension,
			&i.FileName,
			&i.ReleaseGroup,
			&i.Source,
			&i.VideoResolution,
			&i.VideoTerm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
